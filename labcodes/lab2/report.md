# OS lab2 report

苏克

2014011402

计45班


## 练习0

采用meld，将lab1项目中的kdebug.c和trap.c复制到lab2项目中。在WSL下，需要开启X-server才能启动meld的GUI窗口，这里我采用的是Xming。

## 练习1

练习1要求实现first fit内存分配算法，包括块的初始化、内存的分配和回收三部分。

### 初始化：default_init_memmap

初始化时，对每个内存块p (范围是[base, base + n)]) 做SetPageProperty(p)处理。这里值得一提的是，这个函数的Property指的是p->flags的取值PG_property，取值为1代表可以被分配；为0代表不能被分配，和p->property完全不同，不能混淆。除了flags之外，还需要把p->ref清零（表示未被访问过），把p->property置为0，表示并非头结点（但是头节点的该域应该设置为块的总数n，只要特殊处理即可）。

在设置好初始值之后，还需要把page添加进链表中，调用list_add_before函数即可。

### 分配：default_alloc_pages

由于我们要实现的是first fit，所以只要遍历free_list，找到第一个长度>=n的块，然后从这个块的首页开始分配出去n个页即可。分配块p的做法是

```
SetPageReserved(p);
ClearPageProperty(p);
list_del(&(p->page_link));
```

在分配过后，需要考虑如果这一块尚有剩余，需要把剩余的部分（长度为page->property - n）留存下来。我们所采用的方式是将“下一个”块的块首（它本来不是块首）的property设置为剩余部分的值。只要有剩余长度，就一定存在这样的新块首。

### 释放：default_free_pages

释放的过程则稍显繁琐。首先，我们需要找到被释放的块们所应该插入的地方。由于所提供的插入函数是list_add_before，所以我们遍历链表，直到找到一个地址高于所释放地址的页，在其前面插入n个页。这n个页也需要经过初始化处理。

在插入释放的页之后，需要做一个向前和向后合并的工作。首先我们向后（向高地址方向）合并：将所插入页的property加上后一个块的property，再把后一个块首页的property设为0，表示后一个块被我们新释放的块合并了。之后再向前（低地址方向）合并：在链表上向前走（直到遭遇链表头为止），用所遇到的第一个块合并我们新插入的块（因为只有低地址合并高地址）。

这样便完成了练习1的要求，make qemu之后可以

值得一提的是，为了调试，我写了一个check_list函数，检查当前free_list中的块首页。

### 改进空间

first-fit并不关心是否能最合理地分配内存，不在乎分配完成后是否产生了不必要的碎片。可以做这样的改进：在分配内存时选择一个长度最大的块进行分配，防止小段碎片的过多产生。

## 练习2

练习2要求实现get_pte函数，该函数的作用是给出一个虚地址，返回该虚地址对应的PTE的虚地址。如果该虚地址所对应的PTE不存在，则需要新建一个（利用练习1中实现好的工具新建page即可）。

我们首先看一下对于一个虚地址（uintptr_t）la，它
